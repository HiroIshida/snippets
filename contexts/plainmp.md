- plainmp's KinematicModel and skrobot's RobotModel hold independent copies of the robot state; if you let them drift apart every IK, collision check, or plan produced in plainmp stops matching what skrobot shows or executes, because all constraints reference a single shared but manually-updated KinematicModel.
- Immediately before you build constraints or launch a solver, move the freshest skrobot pose into plainmp with spec.reflect_skrobot_model_to_kin(robot_model) (or, for a handful of joints, spec.reflect_joint_positions({...})), and do this on every control tick, viewer drag, or tele-operation so the solver always starts from reality.
- Right after a solver returns, push the solved configuration vector q back into skrobot with spec.set_skrobot_model_state(robot_model, q)—or, if the pose already lives in KinematicModel, mirror it with spec.reflect_kin_to_skrobot_model(robot_model)—to keep visualisers, controllers, logs, and the next planning cycle consistent.
- Joints that are outside spec.control_joint_names but still matter for kinematics (e.g., PR2 torso or an arm you are not planning) remain fixed during optimisation yet must be kept current; use spec.reflect_joint_positions each loop to copy their angles from skrobot into plainmp, or call spec.reflect_skrobot_model_to_kin, otherwise link poses and collisions become wrong.
- For PLANAR or FLOATING bases remember that the base pose is appended to q and must be included whenever you call spec.extract_skrobot_model_q(robot_model) or perform any of the sync operations above.
- Synchronisation is always explicit—caching tricks or deepcopy=False do not change this—and any update you make to plainmp's KinematicModel is instantly global, meaning every constraint object tied to that spec sees the new pose the moment you reflect it.
